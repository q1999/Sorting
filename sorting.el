(defun sort-vector (vector-length sort-type)
  (let ((my-sort sort-type)
        (unsorted-vector (create-unsorted-vector vector-length)))
    (funcall (intern my-sort) unsorted-vector)
    (princ unsorted-vector t)))

(defun create-unsorted-vector (args)
  (fill-unsorted-vector (make-vector args nil)))

(defun fill-unsorted-vector (unsorted-vector)
  (let ((i 0))
    (while (< i (length unsorted-vector))
      (setq ran (random (length unsorted-vector)))
      (when (not (does-vector-contain unsorted-vector ran))
        (aset unsorted-vector i ran)
        (setq i (1+ i))))
    (princ unsorted-vector)
    (eval unsorted-vector)))

(defun does-vector-contain (vector args)
  (let ((k 0)
        (result nil) )
    (while (< k (length vector))
      (setq value-current-slot (aref vector k))
      (if (eq value-current-slot args)
          (setq result value-current-slot))
      (setq k (1+ k)))
    (eval result)))

(defun bubble-sort (unsorted-vector)
  (setq current-slot 0)
  (setq next-slot 1)
  (setq vector-is-sorted nil)
  (while (not vector-is-sorted)
    (when (eq current-slot (- (length unsorted-vector) 1))
      (setq current-slot 0)
      (setq next-slot 1))
    (funcall 'check-is-vector-sorted unsorted-vector)
    (if (> (aref unsorted-vector current-slot)
           (aref unsorted-vector next-slot))
        (swap-slots)
      )
    (setq current-slot (1+ current-slot))
    (setq next-slot (1+ next-slot)))
  (defun swap-slots ()
    (setq higher-value (aref unsorted-vector current-slot))
    (setq lower-value (aref unsorted-vector next-slot))
    (aset unsorted-vector current-slot lower-value)
    (aset unsorted-vector next-slot higher-value)
    )
  )

(defun check-is-vector-sorted (vector-to-check)
  (setq m 0)
  (setq vector-is-sorted t)
  (while (< m (- (length vector-to-check) 1))
    (if (> (aref vector-to-check m) (aref vector-to-check (1+ m)))
      (setq vector-is-sorted nil)
      )
    (setq m (1+ m)))
  )

(defun quick-sort (unsorted-vector)
  (princ "quick-sort has been called...\n")
  ())

